# Перегрузка операторов и другие соглашения

***Соглашения*** - подход в *Kotlin*, который позволяет применять стандартные операторы у типов, для которых были определены специальные функции отвечающие за эти операторы.

### Перегрузка арифметических операторов

##### Бинарные арифметические операторы, доступные для перегрузки:

Выражение | Функция
:--------:|:------:
 *a * b*  | *times*
 *a / b*  | *div*
 *a % b*  | *mod*
 *a + b*  | *plus*
 *a - b*  | *minus*


Операторы транслируются в вызов функции (Компилятор делает это за кулисами)  
*Пример:* `a + b → a.plus(b)`

Чтобы определить операторы для своего класса, необходимо объявить **функцию** с именем этого оператора и модификатором `operator`. Объявить оператор можно также и через **функцию-расширение**.

> **Функции-операторы в Java:**  
> Перегруженные операторы *Kotlin* доступны в *Java* через вызов функций. Вызывая *Java*-код из *Kotlin*, можно использовать синтаксис операторов для любых методов с именами, совпадающими с соглашениями в *Kotlin*. Требования к функции-расширения использовать модификатор `operator` в объявлении функции в *Java*-коде отсутствует. 

Определяя оператор, необязательно использовать одинаковые типы для операндов. Возвращаемое значение также может быть другого типа.

*Kotlin* не поддерживает **коммутативность** (перемену операндов местами), поэтому для создания этой коммутативности необходимо создать функцию-оператор и для другого типа.

Подобно любым другим функциям, функции-операторы могут иметь перегруженные версии.

> **Отсутствие специальных операторов для поразрядных операций**  
> 	В *Kotlin* отсутствуют **битовые операторы** для стандартных типов - и в следствие этого отсутствует возможность определять их для своих типов. Для этих целей используются **обычные функции**, поддерживающие инфиксный синтаксис вызова.  
>  
> **Список функций**
> - `shl` - сдвиг влево со знаком
> - `shr` - сдвиг вправо со знаком
> - `ushr` - сдвиг вправо без знака
> - `and` - поразрядное **"И"**
> - `or` - поразрядное **"ИЛИ"**
> - `xor` - поразрядное **"ИСКЛЮЧАЮЩЕЕ ИЛИ"**
> - `inv` - поразрядная инверсия

#### Перегрузка составных операторов присваивания

Операторы `+=`, `-=` и другие называют **составными операторами присваивания**.

Для составных операторов также можно определить **функцию-оператор**, возвращающую значение типа `Unit`. Такие функции именуются как `plusAssign`, `minusAssign`, `timesAssign` и др. Вызов такой функции возможен только для изменяемой переменной `var`.

Если такая функция-оператор не определена, то компилятор переделывает составной оператор так, что происходит замена текущего объекта, к которому применен составной оператор, на новый объект полученный примением оператора, на котором основан составной оператор.  
*Пример:* `a += b` действует точно так же, как `a = a.plus(b)`

Вызов составного оператора включает в себя вызовы обеих функций-операторов и для обычного оператора (например, `plus`), и для составного оператора (соответственно, `plusAssign`). Поэтому если определены и применимы обе функции, компилятор сообщит об ошибке. 

#### Перегрузка унарных операторов

Функции, используемые для пергрузки унарных операторов, не принимают никаких аргументов.

##### Унарные арифметические операторы, доступные для перегрузки:

Выражение | Функция
:--------:|:------:
 *+a*  | *unaryPlus*
 *-a*  | *unaryMinus*
 *!a*  | *not*
 *++a, a++*  | *inc*
 *--a, a--*  | *dec*
 
### Перегрузка операторов сравнения
 
 _Kotlin_ даёт возможность использовать операторы сравнения (`==`, `!=`, `<`, `>` и другие) с любыми объектами,а не только с простыми типами. Вместо вызова `equals` или `compareTo`, можно использовать непосредственные операторы сравнения.
 
#### Операторы равенства: `equals`
 
Оператор `==` транслируется в `equals` и проверку на равенство _null_ как:  
 `a == b` в `a?.equals(b) ?: (b == null)`

Оператор строгого равенства (идентичности) `===` используется, чтобы проверить ссылочного равенства. Оператор работает в точности как оператор `==` в _Java_: он сравнивает ссылки своих аргументов или значения, если аргументы - значения простого типа.  

В отличие от других соглашений, функция `equals` отмечена модификатором `override` и не требует модификатора `operator`, так как реализация функции с данным модификатором уже содержится в классе `Any` (поэтому поддерживается проверка равенства для всех объектов).

Но `equalse` нельзя реализовать с помощью функций расширений, потому что реализация наследуется из класса `Any` и всегда имеет приоритет перед расширением.
